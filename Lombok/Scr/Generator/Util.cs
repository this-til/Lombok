using Microsoft.CodeAnalysis;
using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Til.Lombok.Generator {

    /// <summary>
    /// Extensions for <see cref="IncrementalGeneratorInitializationContext"/>.
    /// </summary>
    public static class IncrementalGeneratorInitializationContextExtensions {

        /// <summary>
        /// Checks if the result is erroneous and if a diagnostic needs to be raised. If not, it adds the source to the compilation.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="provider"></param>
        public static void AddSources(this IncrementalGeneratorInitializationContext context, IncrementalValuesProvider<GeneratorResult> provider) {
            context.RegisterSourceOutput(provider, AddSources);
        }

        private static void AddSources(SourceProductionContext context, GeneratorResult result) {
            if (result.IsValid) {
                context.AddSource($"{result.TypeName}.g.cs", result.Source!);
            }
            else if (result.Diagnostic is not null) {
                context.ReportDiagnostic(result.Diagnostic);
            }
        }

    }

    /// <summary>
    /// The result class for incremental generators. Either contains source code or a diagnostic which should be raised.
    /// </summary>
    public sealed class GeneratorResult {

        /// <summary>
        /// The name of the generated type.
        /// </summary>
        public string? TypeName { get; }

        /// <summary>
        /// The SourceText of the generated code.
        /// </summary>
        public SourceText? Source { get; }

        /// <summary>
        /// The diagnostic to be raised if something went wrong.
        /// </summary>
        public Diagnostic? Diagnostic { get; }

        /// <summary>
        /// Determines if the result is valid and can be added to the compilation or if the diagnostic needs to be raised.
        /// </summary>
        public bool IsValid => TypeName is not null && Source is not null && Diagnostic is null;

        /// <summary>
        /// An empty result. Something went wrong, however no diagnostic should be reported
        /// </summary>
        public static GeneratorResult Empty { get; } = new();

        /// <summary>
        /// Constructor to be used in case of success.
        /// </summary>
        /// <param name="typeName">The name of the generated type.</param>
        /// <param name="source">The source of the generated code.</param>
        public GeneratorResult(string typeName, SourceText source) {
            TypeName = typeName;
            Source = source;
        }

        /// <summary>
        /// Constructor to be used in case of failure.
        /// </summary>
        /// <param name="diagnostic">The diagnostic to be raised.</param>
        public GeneratorResult(Diagnostic diagnostic) {
            Diagnostic = diagnostic;
        }

        private GeneratorResult() {
        }

    }

    public static class SyntaxNodeExtensions {

        public static readonly SyntaxTriviaList NullableTrivia = TriviaList
        (
            Trivia
            (
                NullableDirectiveTrivia
                (
                    Token(SyntaxKind.EnableKeyword),
                    true
                )
            )
        );

        public static readonly SyntaxTrivia AutoGeneratedComment = Comment("// <auto-generated/>");

        /// <summary>
        /// Traverses a syntax node upwards until it reaches a <code>BaseNamespaceDeclarationSyntax</code>.
        /// </summary>
        /// <param name="node">The syntax node to traverse.</param>
        /// <returns>The namespace this syntax node is in. <code>null</code> if a namespace cannot be found.</returns>
        public static NameSyntax? GetNamespace(this SyntaxNode node) {
            SyntaxNode? parent = node.Parent;
            while (parent != null) {
                if (parent is BaseNamespaceDeclarationSyntax ns) {
                    return ns.Name;
                }

                parent = parent.Parent;
            }

            return null;
        }

        /// <summary>
        /// Gets the using directives from a SyntaxNode. Traverses the tree upwards until it finds using directives.
        /// </summary>
        /// <param name="node">The staring point.</param>
        /// <returns>A list of using directives.</returns>
        public static SyntaxList<UsingDirectiveSyntax> GetUsings(this SyntaxNode node) {
            SyntaxNode? parent = node.Parent;
            while (parent is not null) {
                if (parent is BaseNamespaceDeclarationSyntax ns && ns.Usings.Any()) {
                    return ns.Usings;
                }

                if (parent is CompilationUnitSyntax compilationUnit && compilationUnit.Usings.Any()) {
                    return compilationUnit.Usings;
                }

                parent = parent.Parent;
            }

            return default;
        }

        /// <summary>
        /// Gets the accessibility modifier for a type declaration.
        /// </summary>
        /// <param name="typeDeclaration">The type declaration's accessibility modifier to find.</param>
        /// <returns>The types accessibility modifier.</returns>
        public static SyntaxKind GetAccessibilityModifier(this BaseTypeDeclarationSyntax typeDeclaration) {
            if (typeDeclaration.Modifiers.Any(SyntaxKind.PublicKeyword)) {
                return SyntaxKind.PublicKeyword;
            }

            return SyntaxKind.InternalKeyword;
        }

        /// <summary>
        /// Constructs a new partial class from the original type's name, accessibility and type arguments.
        /// </summary>
        /// <param name="type">The type to clone.</param>
        /// <returns>A new partial class with a few of the original types traits.</returns>
        public static ClassDeclarationSyntax CreateNewPartialClass(this TypeDeclarationSyntax type) {
            ClassDeclarationSyntax declaration = ClassDeclaration(type.Identifier.Text)
                .WithModifiers
                (
                    TokenList
                    (
                        Token(type.GetAccessibilityModifier()),
                        Token(SyntaxKind.PartialKeyword)
                    )
                )
                .WithTypeParameterList(type.TypeParameterList)
                .WithMembers
                (
                    List<MemberDeclarationSyntax>()
                );
            if (type.ShouldEmitNrtTrivia()) {
                declaration = declaration.WithLeadingTrivia(NullableTrivia);
            }

            return declaration;
        }

        public static string toClassName(this BaseTypeDeclarationSyntax baseTypeDeclarationSyntax) {
            if (baseTypeDeclarationSyntax is not TypeDeclarationSyntax typeDeclarationSyntax) {
                return baseTypeDeclarationSyntax.Identifier.Text;
            }
            TypeParameterListSyntax? typeParameterList = typeDeclarationSyntax.TypeParameterList;
            if (typeParameterList == null) {
                return baseTypeDeclarationSyntax.Identifier.Text;
            }
            return $"{baseTypeDeclarationSyntax.Identifier.Text}<{typeParameterList.Parameters.ToString()}>";
        }

        public static string toFileName(this BaseTypeDeclarationSyntax baseTypeDeclarationSyntax) => toClassName(baseTypeDeclarationSyntax).Replace("<", "_").Replace(">", "_").Replace(",", "_");

        /// <summary>
        /// Checks if a TypeSyntax represents void.
        /// </summary>
        /// <param name="typeSyntax">The TypeSyntax to check.</param>
        /// <returns>True, if the type represents void.</returns>
        public static bool IsVoid(this TypeSyntax typeSyntax) {
            return typeSyntax is PredefinedTypeSyntax predefinedType && predefinedType.Keyword.IsKind(SyntaxKind.VoidKeyword);
        }

        /// <summary>
        /// Checks if a type is declared as a nested type.
        /// </summary>
        /// <param name="typeDeclaration">The type to check.</param>
        /// <returns>True, if the type is declared within another type.</returns>
        public static bool IsNestedType(this BaseTypeDeclarationSyntax typeDeclaration) {
            return typeDeclaration.Parent is TypeDeclarationSyntax;
        }

        /// <summary>
        /// Determines if the type is eligible for code generation.
        /// </summary>
        /// <param name="typeDeclaration">The type to check for.</param>
        /// <param name="namespace">The type's namespace. Will be set in this method.</param>
        /// <param name="diagnostic">A diagnostic to be emitted if the type is not valid.</param>
        /// <returns>True, if code can be generated for this type.</returns>
        public static bool TryValidateType(this TypeDeclarationSyntax typeDeclaration, out NameSyntax? @namespace, out Diagnostic? diagnostic) {
            @namespace = null;
            diagnostic = null;

            if (!typeDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword)) {
                diagnostic = Diagnostic.Create(DiagnosticDescriptors.TypeMustBePartial, typeDeclaration.Identifier.GetLocation(), typeDeclaration.Identifier.Text);

                return false;
            }

            if (typeDeclaration.Modifiers.Any(static token => token.Text == "file")) {
                diagnostic = Diagnostic.Create(DiagnosticDescriptors.TypeCannotBeFileLocal, typeDeclaration.Identifier.GetLocation(), typeDeclaration.Identifier.Text);

                return false;
            }
            if (typeDeclaration.IsNestedType()) {
                return false;
            }

            @namespace = typeDeclaration.GetNamespace();
            if (@namespace is null) {
                diagnostic = Diagnostic.Create(DiagnosticDescriptors.TypeMustHaveNamespace, typeDeclaration.Identifier.GetLocation(), typeDeclaration.Identifier.Text);

                return false;
            }

            return true;
        }

        /// <summary>
        /// Creates a unique name for a type which can be used as the hint name in Lombok Generator output.
        /// </summary>
        /// <param name="type">The type to get the name for</param>
        /// <param name="namespace">The namespace which will be prepended to the type using underscores.</param>
        /// <returns>A unique name for the type inside a generator context.</returns>
        public static string GetHintName(this BaseTypeDeclarationSyntax type, NameSyntax @namespace) {
            return string.Concat(@namespace.ToString().Replace('.', '_'), '_', type.toFileName());
        }

        /// <summary>
        /// Determines if the <code>#nullable enable</code> preprocessor directive should be emitted in generated code.
        /// </summary>
        /// <param name="node">The node to determine the nullability context in.</param>
        /// <returns><code>true</code> if the preprocessor directive should be emitted, <code>false</code> otherwise.</returns>
        public static bool ShouldEmitNrtTrivia(this SyntaxNode node) {
            return node.SyntaxTree.Options is CSharpParseOptions opt && (int)opt.LanguageVersion >= (int)LanguageVersion.CSharp8;
        }

        public static SyntaxTriviaList GetLeadingTriviaFromMultipleLocations(this FieldDeclarationSyntax field) {
            SyntaxTriviaList typeTrivia = field.Declaration.Type.GetCommentTrivia();
            if (typeTrivia.Any()) {
                return typeTrivia;
            }

            SyntaxTriviaList modifierTrivia = field.Modifiers.First().GetCommentTrivia();
            if (modifierTrivia.Any()) {
                return modifierTrivia;
            }

            AttributeListSyntax attributeList = field.AttributeLists[0];

            return attributeList.OpenBracketToken.GetCommentTrivia();
        }

        public static SyntaxTriviaList GetCommentTrivia(this SyntaxToken token) {
            if (token.LeadingTrivia.Any(SyntaxKind.SingleLineCommentTrivia) || token.LeadingTrivia.Any(SyntaxKind.MultiLineCommentTrivia)) {
                return token.LeadingTrivia;
            }

            return default;
        }

        public static SyntaxTriviaList GetCommentTrivia(this TypeSyntax type) {
            if (type is PredefinedTypeSyntax predefinedType) {
                return predefinedType.Keyword.GetCommentTrivia();
            }

            if (type is IdentifierNameSyntax identifier) {
                return identifier.Identifier.GetCommentTrivia();
            }

            return default;
        }

        public static IEnumerable<INamedTypeSymbol> GetAllTypeSymbol(this INamespaceSymbol namespaceSymbol) {
            ImmutableArray<INamedTypeSymbol> typeMemberList = namespaceSymbol.GetTypeMembers();

            foreach (INamedTypeSymbol? typeSymbol in typeMemberList) {
                yield return typeSymbol;
            }

            foreach (INamespaceSymbol? namespaceMember in namespaceSymbol.GetNamespaceMembers()) {
                foreach (INamedTypeSymbol? typeSymbol in GetAllTypeSymbol(namespaceMember)) {
                    yield return typeSymbol;
                }
            }
        }

        public static IEnumerable<AttributeSyntax> tryGetSpecifiedAttribute(this IEnumerable<AttributeListSyntax> attributeLists, string attributeName) {
            string noAttribute = attributeName;

            if (attributeName.EndsWith("Attribute")) {
                noAttribute = attributeName.Substring(0, attributeName.Length - 9);
            }

            foreach (AttributeListSyntax attributeList in attributeLists) {
                foreach (AttributeSyntax attribute in attributeList.Attributes) {
                    if (attributeName.Equals(attribute.Name.ToString()) || noAttribute.Equals(attribute.Name.ToString())) {
                        yield return attribute;
                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="attribute"></param>
        /// <param name="semanticModel"></param>
        /// <returns></returns>
        public static Dictionary<string, string> getAttributeArgumentsAsDictionary(this AttributeSyntax attribute, SemanticModel semanticModel) {
            Dictionary<string, string> dictionary = new Dictionary<string, string>();

            if (attribute.ArgumentList != null) {
                foreach (AttributeArgumentSyntax argument in attribute.ArgumentList.Arguments) {
                    string? key = argument.NameEquals?.Name.Identifier.ToString() ?? null;
                    if (key is null) {
                        continue;
                    }

                    string? value;
                    try {
                        value = ExtractAttributeValue(argument.Expression, semanticModel);
                    }
                    catch (Exception _) {
                        value = argument.Expression.ToString();
                        int breakPoint = value.LastIndexOf('.');
                        if (breakPoint != -1) {
                            value = value.Substring(breakPoint + 1, value.Length - breakPoint - 1);
                        }
                    }

                    if (value is null) {
                        continue;
                    }
                    dictionary.Add(key, value);
                }
            }

            return dictionary;
        }

        public static string getHasGenericName(this ClassDeclarationSyntax classDeclarationSyntax) {
            string className = classDeclarationSyntax.Identifier.ValueText;

            if (classDeclarationSyntax.TypeParameterList is null) {
                return className;
            }

            SeparatedSyntaxList<TypeParameterSyntax> typeParameters = classDeclarationSyntax.TypeParameterList.Parameters;

            // 你可以遍历这些参数，或者将它们格式化为字符串  
            string genericParameters = string.Join(", ", typeParameters.Select(tp => tp.Identifier.ValueText));

            // 输出包含泛型参数的类名  
            return $"{className}<{genericParameters}>";
        }

        public static string? ExtractAttributeValue(ExpressionSyntax expression, SemanticModel semanticModel) {
            switch (expression) {
                // 如果是成员访问表达式（如ConstString.metadata）    
                case MemberAccessExpressionSyntax memberAccess: {
                    // 获取成员访问的符号信息    
                    ISymbol? symbol = semanticModel.GetSymbolInfo(memberAccess).Symbol;

                    // 如果符号是常量，则尝试获取其值    
                    if (symbol is IFieldSymbol fieldSymbol) {
                        if (fieldSymbol.ContainingType.TypeKind == TypeKind.Enum) {
                            return fieldSymbol.Name;
                        }

                        if (fieldSymbol.HasConstantValue) {
                            return fieldSymbol.ConstantValue.ToString();
                        }
                    }
                    break;
                }
                case LiteralExpressionSyntax literal:
                    switch (literal.Kind()) {
                        case SyntaxKind.TrueLiteralExpression:
                            return "true";
                        case SyntaxKind.FalseLiteralExpression:
                            return "false";
                        case SyntaxKind.NumericLiteralExpression:
                        case SyntaxKind.StringLiteralExpression:
                            return literal.Token.Value?.ToString();
                    }
                    break;
                case IdentifierNameSyntax identifierName: {
                    // 获取nameof表达式指向的符号  
                    var symbolInfo = semanticModel.GetSymbolInfo(identifierName);

                    // 确保获取到的是有效的本地变量、参数或成员  
                    if (symbolInfo.Symbol is not null
                        && symbolInfo.Symbol.Kind == SymbolKind.Local
                        || symbolInfo.Symbol!.Kind == SymbolKind.Parameter
                        || symbolInfo.Symbol.Kind == SymbolKind.Property
                        || symbolInfo.Symbol.Kind == SymbolKind.Field
                        || symbolInfo.Symbol.Kind == SymbolKind.Method) {
                        // nameof表达式的结果就是符号的名称  
                        return symbolInfo.Symbol.Name;
                    }
                    break;
                }
                case InvocationExpressionSyntax invocationExpressionSyntax: {

                    ExpressionSyntax expressionSyntax = invocationExpressionSyntax.Expression;

                    if (expressionSyntax is not IdentifierNameSyntax identifierNameSyntax) {
                        break;
                    }
                    if (!identifierNameSyntax.Identifier.Text.Equals("nameof")) {
                        break;
                    }

                    ArgumentListSyntax argumentListSyntax = invocationExpressionSyntax.ArgumentList;

                    SeparatedSyntaxList<ArgumentSyntax> separatedSyntaxList = argumentListSyntax.Arguments;
                    if (separatedSyntaxList.Count == 0) {
                        break;
                    }

                    ArgumentSyntax separatedSyntax = separatedSyntaxList[0];

                    string s = separatedSyntax.ToString();
                    int lastIndexOf = s.LastIndexOf('.');
                    if (lastIndexOf == -1) {
                        return s;
                    }
                    return s.Substring(lastIndexOf + 1);

                }
            }

            return null;
        }

    }

    /// <summary>
    /// Contains definitions of diagnostics which can be raised by Lombok.NET.
    /// </summary>
    public static class DiagnosticDescriptors {

        /// <summary>
        /// Raised when a type is not partial although it should be.
        /// </summary>
        public static readonly DiagnosticDescriptor TypeMustBePartial = new
        (
            "LOM001",
            "Type must be partial",
            "The type '{0}' must be partial in order to generate code for it",
            "Usage",
            DiagnosticSeverity.Error,
            true
        );

        /// <summary>
        /// Raised when a type is not within a namespace although it should be.
        /// </summary>
        public static readonly DiagnosticDescriptor TypeMustHaveNamespace = new
        (
            "LOM003",
            "Type must have namespace",
            "The type '{0}' must be in a namespace in order to generate code for it",
            "Usage",
            DiagnosticSeverity.Error,
            true
        );

        /// <summary>
        /// Raised when a type is file-local.
        /// </summary>
        public static readonly DiagnosticDescriptor TypeCannotBeFileLocal = new
        (
            "LOM007",
            "Type cannot be file-local",
            "The type '{0}' must not be file-local in order to generate code for it.",
            "Usage",
            DiagnosticSeverity.Error,
            true
        );

    }

    internal static class StringExtensions {

        // Taken from https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/
        private static readonly ISet<string> ReservedKeywords = new HashSet<string> {
            "abstract",
            "as",
            "base",
            "bool",
            "break",
            "byte",
            "case",
            "catch",
            "char",
            "checked",
            "class",
            "const",
            "continue",
            "decimal",
            "default",
            "delegate",
            "do",
            "double",
            "else",
            "enum",
            "event",
            "explicit",
            "extern",
            "false",
            "finally",
            "fixed",
            "float",
            "for",
            "foreach",
            "goto",
            "if",
            "implicit",
            "in",
            "int",
            "interface",
            "internal",
            "is",
            "lock",
            "long",
            "namespace",
            "new",
            "null",
            "object",
            "operator",
            "out",
            "override",
            "params",
            "private",
            "protected",
            "public",
            "readonly",
            "ref",
            "return",
            "sbyte",
            "sealed",
            "short",
            "sizeof",
            "stackalloc",
            "static",
            "string",
            "struct",
            "switch",
            "this",
            "throw",
            "true",
            "try",
            "typeof",
            "uint",
            "ulong",
            "unchecked",
            "unsafe",
            "ushort",
            "using",
            "virtual",
            "void",
            "volatile",
            "while"
        };

        /// <summary>
        /// Lowercases the first character of a given string.
        /// </summary>
        /// <param name="s">The string whose first character to lowercase.</param>
        /// <returns>The string with its first character lowercased.</returns>
        public static string Decapitalize(this string? s) {
            if (s is null || char.IsLower(s[0])) {
                return s ?? String.Empty;
            }

            return char.ToLower(s[0]) + s.Substring(1);
        }

        /// <summary>
        /// Uppercases the first character of a given string.
        /// </summary>
        /// <param name="s">The string whose first character to uppercase.</param>
        /// <returns>The string with its first character uppercased.</returns>
        public static string Capitalize(this string? s) {
            if (s is null || char.IsUpper(s[0])) {
                return s ?? String.Empty;
            }

            return char.ToUpper(s[0]) + s.Substring(1);
        }

        /// <summary>
        /// Escapes a reserved keyword which should be used as an identifier.
        /// </summary>
        /// <param name="identifier">The identifier to be used.</param>
        /// <returns>A valid identifier.</returns>
        public static string EscapeReservedKeyword(this string identifier) {
            if (ReservedKeywords.Contains(identifier)) {
                return "@" + identifier;
            }

            return identifier;
        }

        public static string genericEliminate(this string identifier) {
            string pattern = @"<[^>]+>"; // 匹配 < 和 > 之间的任何内容（不包括这两个尖括号）  
            return Regex.Replace(identifier, pattern, "");
        }

        /// <summary>
        /// Ensures normal PascalCase for an identifier. (e.g. "_age" becomes "Age").
        /// </summary>
        /// <param name="identifier">The identifier to get the property name for.</param>
        /// <returns>A PascalCase identifier.</returns>
        public static string toPascalCaseIdentifier(this string identifier) {
            int tailor = -1;
            for (var i = 0; i < identifier.Length; i++) {
                if (identifier[i] != '_') {
                    break;
                }
                tailor = i;
            }
            if (tailor != -1) {
                identifier = identifier.Substring(tailor + 1);
            }
            return identifier.Capitalize().Replace('.', '_');
        }

        /// <summary>
        /// Transforms an identifier to camelCase. (e.g. "_myAge" -> "myAge", "MyAge" -> "myAge").
        /// </summary>
        /// <param name="identifier">The identifier to transform.</param>
        /// <returns>A camelCase identifier.</returns>
        public static string toCamelCaseIdentifier(this string identifier) {
            int tailor = -1;
            for (var i = 0; i < identifier.Length; i++) {
                if (identifier[i] != '_') {
                    break;
                }
                tailor = i;
            }
            if (tailor != -1) {
                identifier = identifier.Substring(tailor + 1);
            }
            return identifier.Decapitalize().Replace('.', '_');
        }

    }

    public static class Util {

        public static void format(this string format, StringBuilder? stringBuilder, Action<string> structure) {
            if (format == null || structure == null) {
                throw new ArgumentNullException
                (
                    (format == null)
                        ? "format"
                        : "args"
                );
            }

            bool startBrace = false;
            int startBraceIndex = -1;

            for (var i = 0; i < format.Length; i++) {
                char c = format[i];

                switch (c) {
                    case '{':

                        if (startBrace) {
                            if (i - startBraceIndex == 1) {
                                startBrace = false;
                                stringBuilder?.Append('{');
                                break;
                            }
                            ThrowFormatException();
                        }

                        startBrace = true;
                        startBraceIndex = i;

                        break;
                    case '}':

                        if (!startBrace) {
                            if (i + 1 < format.Length && format[i] == '}') {
                                stringBuilder?.Append('}');
                                i++;
                                break;
                            }

                            ThrowFormatException();
                        }

                        startBrace = false;

                        string key = format.Substring(startBraceIndex + 1, i - startBraceIndex - 1);

                        structure(key);

                        break;
                    default:

                        if (!startBrace) {
                            stringBuilder?.Append(c);
                        }

                        break;
                }
            }
        }

        private static void ThrowFormatException() {
            throw new FormatException("Input string was not in a correct format.");
        }

        public static O noNullOrDef<O>(this O? o, O def) => o ?? def;

        public static void PrintExceptionSummaryAndStackTrace(this Exception ex) {
            // 获取堆栈跟踪的第一帧  
            StackTrace stackTrace = new StackTrace(ex, true);
            StackFrame firstFrame = stackTrace.GetFrame(0);

            // 格式化文件名、行号和列号为紧凑字符串  
            string fileLocation = firstFrame.GetFileName() != null
                ? $"{firstFrame.GetFileName()}[{firstFrame.GetFileLineNumber()}, {firstFrame.GetFileColumnNumber()}]"
                : "Unknown file[0, 0]";

            // 格式化一行简化的异常信息  
            string summary = $"Exception Message: {ex.Message}, Type: {ex.GetType()}, Method: {firstFrame.GetMethod().DeclaringType?.FullName}.{firstFrame.GetMethod().Name}, Location: {fileLocation}";

            // 打印简化的异常信息  
            Console.WriteLine(summary);

            // 打印完整的堆栈跟踪信息  
            foreach (StackFrame frame in stackTrace.GetFrames() ?? Array.Empty<StackFrame>()) {
                MethodBase method = frame.GetMethod();
                string fileName = frame.GetFileName() ?? "Unknown file";
                int fileLineNumber = frame.GetFileLineNumber();
                int fileColumnNumber = frame.GetFileColumnNumber();

                string frameLocation = $"{fileName}[{fileLineNumber}, {fileColumnNumber}]";
                Console.WriteLine($"    Method: {method.DeclaringType?.FullName}.{method.Name}, Location: {frameLocation}");
            }

            Console.WriteLine();

            // 如果异常有内部异常，也打印出来  
            if (ex.InnerException != null) {
                Console.WriteLine("Inner Exception:");
                PrintExceptionSummaryAndStackTrace(ex.InnerException);
            }
        }

        public static string mackCustomName(string source, string? fillSource, MetadataAttribute metadataAttribute) {

            fillSource ??= source;

            if (metadataAttribute.customName is not null) {
                return metadataAttribute.customName;
            }

            if (metadataAttribute.customPrefix is not null) {
                return metadataAttribute.customPrefix + source.toPascalCaseIdentifier();
            }

            if (metadataAttribute.customSuffix is not null) {
                return fillSource + metadataAttribute.customSuffix;
            }

            return source;
        }

    }

    public static class GeneratorUtil {

        public static MethodDeclarationSyntax applyAll<A>
        (
            this MethodDeclarationSyntax methodDeclarationSyntax,
            FieldsAttributeContext<A> fieldsAttributeContext,
            AttributeContext<A> firstAttribute
        ) where A : MetadataAttribute {
            return methodDeclarationSyntax
                .applyCustomName(firstAttribute.attribute, fieldsAttributeContext.fieldsContext.fieldName)
                .applyLink(firstAttribute.attribute, fieldsAttributeContext.basicsContext.className)
                .applyNoNull(firstAttribute.attribute)
                .applyFrozen(firstAttribute.attribute)
                .applyDeclarationSyntaxes(firstAttribute.attribute);

        }

        public static MethodDeclarationSyntax applyFrozen(this MethodDeclarationSyntax methodDeclarationSyntax, MetadataAttribute metadataAttribute) {
            if (metadataAttribute.freezeTag is null) {
                return methodDeclarationSyntax;
            }
            if (methodDeclarationSyntax.Body is null) {
                return methodDeclarationSyntax;
            }

            return methodDeclarationSyntax.WithBody
            (
                Block
                (
                    methodDeclarationSyntax.Body.Statements.Insert
                    (
                        0,
                        ExpressionStatement
                        (
                            InvocationExpression
                            (
                                MemberAccessExpression
                                (
                                    SyntaxKind.SimpleMemberAccessExpression, // 使用点号访问  ,
                                    ThisExpression(),
                                    IdentifierName
                                    (
                                        "validateNonFrozen"
                                    )
                                ),
                                ArgumentList
                                (
                                    SingletonSeparatedList
                                    (
                                        Argument
                                        (
                                            LiteralExpression
                                            (
                                                SyntaxKind.StringLiteralExpression,
                                                Literal
                                                (
                                                    metadataAttribute.freezeTag
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            );
        }

        public static MethodDeclarationSyntax applyNoNull(this MethodDeclarationSyntax methodDeclarationSyntax, MetadataAttribute metadataAttribute) {

            if (!metadataAttribute.noNull) {
                return methodDeclarationSyntax;
            }

            if (methodDeclarationSyntax.Body is null) {
                return methodDeclarationSyntax;
            }

            return methodDeclarationSyntax.WithBody
            (
                Block
                (
                    methodDeclarationSyntax.Body.Statements.InsertRange
                    (
                        0,
                        methodDeclarationSyntax.ParameterList.Parameters.Select
                        (
                            parameterListParameter => IfStatement
                            (
                                BinaryExpression
                                (
                                    SyntaxKind.EqualsExpression,
                                    IdentifierName(parameterListParameter.Identifier.Text),
                                    LiteralExpression(SyntaxKind.NullLiteralExpression)
                                ),
                                Block
                                (
                                    ThrowStatement
                                    (
                                        ObjectCreationExpression
                                        (
                                            ParseTypeName("System.NullReferenceException"),
                                            ArgumentList
                                            (
                                                SeparatedList
                                                (
                                                    new[] {
                                                        Argument
                                                        (
                                                            LiteralExpression
                                                            (
                                                                SyntaxKind.StringLiteralExpression,
                                                                Literal
                                                                (
                                                                    $"{methodDeclarationSyntax.Identifier.Text}.{parameterListParameter.Identifier.Text} is null"
                                                                )
                                                            )
                                                        )
                                                    }
                                                )
                                            ),
                                            null
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            );

        }

        public static MethodDeclarationSyntax applyCustomName(this MethodDeclarationSyntax methodDeclarationSyntax, MetadataAttribute metadataAttribute, string fieldName) {

            if (!metadataAttribute.isCustomName()) {
                return methodDeclarationSyntax;
            }

            methodDeclarationSyntax = methodDeclarationSyntax.WithIdentifier
            (
                Identifier
                (
                    Util.mackCustomName(fieldName, methodDeclarationSyntax.Identifier.Text, metadataAttribute)
                )
            );

            return methodDeclarationSyntax;

        }

        public static MethodDeclarationSyntax applyDeclarationSyntaxes(this MethodDeclarationSyntax methodDeclarationSyntax, MetadataAttribute metadataAttribute) {
            switch (metadataAttribute.accessLevel) {
                case AccessLevel.Private:
                    methodDeclarationSyntax = methodDeclarationSyntax.AddModifiers
                    (
                        Token
                        (
                            SyntaxKind.PrivateKeyword
                        )
                    );
                    break;
                case AccessLevel.Protected:
                    methodDeclarationSyntax = methodDeclarationSyntax.AddModifiers
                    (
                        Token
                        (
                            SyntaxKind.ProtectedKeyword
                        )
                    );
                    break;
                case AccessLevel.ProtectedInternal:
                    methodDeclarationSyntax = methodDeclarationSyntax.AddModifiers
                    (
                        Token
                        (
                            SyntaxKind.ProtectedKeyword
                        ),
                        Token
                        (
                            SyntaxKind.InternalKeyword
                        )
                    );
                    break;
                case AccessLevel.Internal:
                    methodDeclarationSyntax = methodDeclarationSyntax.AddModifiers
                    (
                        Token
                        (
                            SyntaxKind.InternalKeyword
                        )
                    );
                    break;
                case AccessLevel.Public:
                    methodDeclarationSyntax = methodDeclarationSyntax.AddModifiers
                    (
                        Token
                        (
                            SyntaxKind.PublicKeyword
                        )
                    );
                    break;
            }

            switch (metadataAttribute.methodType) {
                case MethodType.def:
                    break;
                case MethodType.Abstract:
                    methodDeclarationSyntax = methodDeclarationSyntax.WithBody(null)
                        .AddModifiers
                        (
                            Token
                            (
                                SyntaxKind.AbstractKeyword
                            )
                        )
                        .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
                    break;
                case MethodType.Partial:
                    methodDeclarationSyntax = methodDeclarationSyntax.WithBody(null)
                        .AddModifiers
                        (
                            Token
                            (
                                SyntaxKind.PartialKeyword
                            )
                        )
                        .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
                    break;
                case MethodType.Override:
                    methodDeclarationSyntax = methodDeclarationSyntax.AddModifiers
                    (
                        Token
                        (
                            SyntaxKind.OverrideKeyword
                        )
                    );
                    break;
                case MethodType.Virtual:
                    methodDeclarationSyntax = methodDeclarationSyntax.AddModifiers
                    (
                        Token
                        (
                            SyntaxKind.VirtualKeyword
                        )
                    );
                    break;
            }
            return methodDeclarationSyntax;
        }

        public static MethodDeclarationSyntax applyLink
        (
            this MethodDeclarationSyntax methodDeclarationSyntax,
            MetadataAttribute metadataAttribute,
            string className
        ) {
            if (!metadataAttribute.link) {
                return methodDeclarationSyntax;
            }

            TypeSyntax returnType = methodDeclarationSyntax.ReturnType;
            if (!returnType.ToString().Equals("void")) {
                return methodDeclarationSyntax;
            }

            methodDeclarationSyntax = methodDeclarationSyntax
                .WithReturnType
                (
                    IdentifierName(className)
                );

            if (methodDeclarationSyntax.Body is null) {
                return methodDeclarationSyntax;
            }

            return methodDeclarationSyntax
                .AddBodyStatements
                (
                    ReturnStatement
                    (
                        ThisExpression()
                    )
                );
        }

        public static MethodDeclarationSyntax applyUpdateField(this MethodDeclarationSyntax methodDeclarationSyntax, MetadataAttribute metadataAttribute, string fieldName) {

            if (!metadataAttribute.updateField) {
                return methodDeclarationSyntax;
            }

            if (methodDeclarationSyntax.Body is null) {
                return methodDeclarationSyntax;
            }

            return methodDeclarationSyntax
                .WithBody
                (
                    Block
                    (
                        methodDeclarationSyntax.Body.Statements.Insert
                        (
                            0,
                            IfStatement
                            (
                                InvocationExpression
                                (
                                    MemberAccessExpression
                                    (
                                        SyntaxKind.SimpleMemberAccessExpression,
                                        IdentifierName
                                        (
                                            "object"
                                        ),
                                        IdentifierName
                                        (
                                            nameof(Equals)
                                        )
                                    ),
                                    ArgumentList
                                    (
                                        SeparatedList
                                        (
                                            new[] {
                                                Argument
                                                (
                                                    MemberAccessExpression
                                                    (
                                                        SyntaxKind.SimpleMemberAccessExpression,
                                                        ThisExpression(),
                                                        IdentifierName
                                                        (
                                                            fieldName
                                                        )
                                                    )
                                                ),
                                                Argument
                                                (
                                                    IdentifierName
                                                    (
                                                        fieldName
                                                    )
                                                ),
                                            }
                                        )
                                    )
                                ),
                                Block
                                (
                                    ExpressionStatement
                                    (
                                        InvocationExpression
                                        (
                                            MemberAccessExpression
                                            (
                                                SyntaxKind.SimpleMemberAccessExpression, // 使用点号访问  ,
                                                ThisExpression(),
                                                IdentifierName
                                                (
                                                    "update" + fieldName.toPascalCaseIdentifier()
                                                )
                                            ),
                                            ArgumentList
                                            (
                                                SeparatedList
                                                (
                                                    new[] {
                                                        Argument
                                                        (
                                                            MemberAccessExpression
                                                            (
                                                                SyntaxKind.SimpleMemberAccessExpression,
                                                                ThisExpression(),
                                                                IdentifierName
                                                                (
                                                                    fieldName
                                                                )
                                                            )
                                                        ),
                                                        Argument
                                                        (
                                                            IdentifierName
                                                            (
                                                                fieldName
                                                            )
                                                        ),
                                                    }
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                );
        }

    }

    public partial class CodeBuilder {

        public readonly StringBuilder stringBuilder;

        public int indentation;

        protected bool start;

        public CodeBuilder(StringBuilder stringBuilder) {
            this.stringBuilder = stringBuilder;
        }


        public void append(string s) {
            if (start) {
                start = false;
                for (int i = 0; i < indentation; i++) {
                    stringBuilder.Append("    ");
                }
            }
            stringBuilder.Append(s);
        }

        public IDisposable appendBracket(string s) {
            append(s);
            return appendBracket();
        }

        public IDisposable appendBracket() {
            stringBuilder.Append('(');
            return new CodeBuilderDisposable(() => append(")"));
        }

        public void appendLine(string s) {
            append(s);
            stringBuilder.Append('\n');
            start = true;
        }

        public IDisposable appendBlock(string s, bool lineFeed = true) {
            append(s);
            return block(lineFeed);
        }

        public IDisposable block(bool lineFeed = true) {
            indentation++;
            stringBuilder.Append(' ').Append('{').Append('\n');
            start = true;
            return new CodeBuilderDisposable
            (
                () => {
                    indentation--;
                    if (lineFeed) {
                        appendLine("}");
                    }
                    else {
                        append("}");
                    }
                }
            );
        }

        public class CodeBuilderDisposable : IDisposable {

            public readonly Action dispose;

            public CodeBuilderDisposable(Action dispose) {
                this.dispose = dispose;
            }

            public void Dispose() => dispose();

        }

    }

}
