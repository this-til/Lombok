using Microsoft.CodeAnalysis;
using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Transactions;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Til.Lombok.Generator {

    /// <summary>
    /// Extensions for <see cref="IncrementalGeneratorInitializationContext"/>.
    /// </summary>
    public static class IncrementalGeneratorInitializationContextExtensions {

        /// <summary>
        /// Checks if the result is erroneous and if a diagnostic needs to be raised. If not, it adds the source to the compilation.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="provider"></param>
        public static void AddSources(this IncrementalGeneratorInitializationContext context, IncrementalValuesProvider<GeneratorResult> provider) {
            context.RegisterSourceOutput(provider, AddSources);
        }

        private static void AddSources(SourceProductionContext context, GeneratorResult result) {
            if (result.IsValid) {
                context.AddSource($"{result.TypeName}.g.cs", result.Source!);
            }
            else if (result.Diagnostic is not null) {
                context.ReportDiagnostic(result.Diagnostic);
            }
        }

    }

    /// <summary>
    /// The result class for incremental generators. Either contains source code or a diagnostic which should be raised.
    /// </summary>
    public sealed class GeneratorResult {

        /// <summary>
        /// The name of the generated type.
        /// </summary>
        public string? TypeName { get; }

        /// <summary>
        /// The SourceText of the generated code.
        /// </summary>
        public SourceText? Source { get; }

        /// <summary>
        /// The diagnostic to be raised if something went wrong.
        /// </summary>
        public Diagnostic? Diagnostic { get; }

        /// <summary>
        /// Determines if the result is valid and can be added to the compilation or if the diagnostic needs to be raised.
        /// </summary>
        public bool IsValid => TypeName is not null && Source is not null && Diagnostic is null;

        /// <summary>
        /// An empty result. Something went wrong, however no diagnostic should be reported
        /// </summary>
        public static GeneratorResult Empty { get; } = new();

        /// <summary>
        /// Constructor to be used in case of success.
        /// </summary>
        /// <param name="typeName">The name of the generated type.</param>
        /// <param name="source">The source of the generated code.</param>
        public GeneratorResult(string typeName, SourceText source) {
            TypeName = typeName;
            Source = source;
        }

        /// <summary>
        /// Constructor to be used in case of failure.
        /// </summary>
        /// <param name="diagnostic">The diagnostic to be raised.</param>
        public GeneratorResult(Diagnostic diagnostic) {
            Diagnostic = diagnostic;
        }

        private GeneratorResult() {
        }

    }

    public static class SyntaxNodeExtensions {

        public static readonly SyntaxTriviaList NullableTrivia = TriviaList
        (
            Trivia
            (
                NullableDirectiveTrivia
                (
                    Token(SyntaxKind.EnableKeyword),
                    true
                )
            )
        );

        public static readonly SyntaxTrivia AutoGeneratedComment = Comment("// <auto-generated/>");

        /// <summary>
        /// Traverses a syntax node upwards until it reaches a <code>BaseNamespaceDeclarationSyntax</code>.
        /// </summary>
        /// <param name="node">The syntax node to traverse.</param>
        /// <returns>The namespace this syntax node is in. <code>null</code> if a namespace cannot be found.</returns>
        public static NameSyntax? GetNamespace(this SyntaxNode node) {
            SyntaxNode? parent = node.Parent;
            while (parent != null) {
                if (parent is BaseNamespaceDeclarationSyntax ns) {
                    return ns.Name;
                }

                parent = parent.Parent;
            }

            return null;
        }

        /// <summary>
        /// Gets the using directives from a SyntaxNode. Traverses the tree upwards until it finds using directives.
        /// </summary>
        /// <param name="node">The staring point.</param>
        /// <returns>A list of using directives.</returns>
        public static SyntaxList<UsingDirectiveSyntax> GetUsings(this SyntaxNode node) {
            SyntaxNode? parent = node.Parent;
            while (parent is not null) {
                if (parent is BaseNamespaceDeclarationSyntax ns && ns.Usings.Any()) {
                    return ns.Usings;
                }

                if (parent is CompilationUnitSyntax compilationUnit && compilationUnit.Usings.Any()) {
                    return compilationUnit.Usings;
                }

                parent = parent.Parent;
            }

            return default;
        }

        /// <summary>
        /// Gets the accessibility modifier for a type declaration.
        /// </summary>
        /// <param name="typeDeclaration">The type declaration's accessibility modifier to find.</param>
        /// <returns>The types accessibility modifier.</returns>
        public static SyntaxKind GetAccessibilityModifier(this BaseTypeDeclarationSyntax typeDeclaration) {
            if (typeDeclaration.Modifiers.Any(SyntaxKind.PublicKeyword)) {
                return SyntaxKind.PublicKeyword;
            }

            return SyntaxKind.InternalKeyword;
        }

        /// <summary>
        /// Constructs a new partial class from the original type's name, accessibility and type arguments.
        /// </summary>
        /// <param name="type">The type to clone.</param>
        /// <returns>A new partial class with a few of the original types traits.</returns>
        public static ClassDeclarationSyntax CreateNewPartialClass(this TypeDeclarationSyntax type) {
            ClassDeclarationSyntax declaration = ClassDeclaration(type.Identifier.Text)
                .WithModifiers
                (
                    TokenList
                    (
                        Token(type.GetAccessibilityModifier()),
                        Token(SyntaxKind.PartialKeyword)
                    )
                )
                .WithTypeParameterList(type.TypeParameterList)
                .WithMembers
                (
                    List<MemberDeclarationSyntax>()
                );
            if (type.ShouldEmitNrtTrivia()) {
                declaration = declaration.WithLeadingTrivia(NullableTrivia);
            }

            return declaration;
        }

        public static string toClassName(this BaseTypeDeclarationSyntax baseTypeDeclarationSyntax) {
            if (baseTypeDeclarationSyntax is not TypeDeclarationSyntax typeDeclarationSyntax) {
                return baseTypeDeclarationSyntax.Identifier.Text;
            }
            TypeParameterListSyntax? typeParameterList = typeDeclarationSyntax.TypeParameterList;
            if (typeParameterList == null) {
                return baseTypeDeclarationSyntax.Identifier.Text;
            }
            return $"{baseTypeDeclarationSyntax.Identifier.Text}<{typeParameterList.Parameters.ToString()}>";
        }

        public static string toFileName(this BaseTypeDeclarationSyntax baseTypeDeclarationSyntax) => toClassName(baseTypeDeclarationSyntax).Replace("<", "_").Replace(">", "_").Replace(",", "_");

        /// <summary>
        /// Checks if a TypeSyntax represents void.
        /// </summary>
        /// <param name="typeSyntax">The TypeSyntax to check.</param>
        /// <returns>True, if the type represents void.</returns>
        public static bool IsVoid(this TypeSyntax typeSyntax) {
            return typeSyntax is PredefinedTypeSyntax predefinedType && predefinedType.Keyword.IsKind(SyntaxKind.VoidKeyword);
        }

        /// <summary>
        /// Checks if a type is declared as a nested type.
        /// </summary>
        /// <param name="typeDeclaration">The type to check.</param>
        /// <returns>True, if the type is declared within another type.</returns>
        public static bool IsNestedType(this BaseTypeDeclarationSyntax typeDeclaration) {
            return typeDeclaration.Parent is TypeDeclarationSyntax;
        }

        /// <summary>
        /// Determines if the type is eligible for code generation.
        /// </summary>
        /// <param name="typeDeclaration">The type to check for.</param>
        /// <param name="namespace">The type's namespace. Will be set in this method.</param>
        /// <param name="diagnostic">A diagnostic to be emitted if the type is not valid.</param>
        /// <returns>True, if code can be generated for this type.</returns>
        public static bool TryValidateType(this TypeDeclarationSyntax typeDeclaration, out NameSyntax? @namespace, out Diagnostic? diagnostic) {
            @namespace = null;
            diagnostic = null;

            if (!typeDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword)) {
                diagnostic = Diagnostic.Create(DiagnosticDescriptors.TypeMustBePartial, typeDeclaration.Identifier.GetLocation(), typeDeclaration.Identifier.Text);

                return false;
            }

            if (typeDeclaration.Modifiers.Any(static token => token.Text == "file")) {
                diagnostic = Diagnostic.Create(DiagnosticDescriptors.TypeCannotBeFileLocal, typeDeclaration.Identifier.GetLocation(), typeDeclaration.Identifier.Text);

                return false;
            }
            if (typeDeclaration.IsNestedType()) {
                return false;
            }

            @namespace = typeDeclaration.GetNamespace();
            if (@namespace is null) {
                diagnostic = Diagnostic.Create(DiagnosticDescriptors.TypeMustHaveNamespace, typeDeclaration.Identifier.GetLocation(), typeDeclaration.Identifier.Text);

                return false;
            }

            return true;
        }

        /// <summary>
        /// Creates a unique name for a type which can be used as the hint name in Lombok Generator output.
        /// </summary>
        /// <param name="type">The type to get the name for</param>
        /// <param name="namespace">The namespace which will be prepended to the type using underscores.</param>
        /// <returns>A unique name for the type inside a generator context.</returns>
        public static string GetHintName(this BaseTypeDeclarationSyntax type, NameSyntax @namespace) {
            return string.Concat(@namespace.ToString().Replace('.', '_'), '_', type.toFileName());
        }

        /// <summary>
        /// Determines if the <code>#nullable enable</code> preprocessor directive should be emitted in generated code.
        /// </summary>
        /// <param name="node">The node to determine the nullability context in.</param>
        /// <returns><code>true</code> if the preprocessor directive should be emitted, <code>false</code> otherwise.</returns>
        public static bool ShouldEmitNrtTrivia(this SyntaxNode node) {
            return node.SyntaxTree.Options is CSharpParseOptions opt && (int)opt.LanguageVersion >= (int)LanguageVersion.CSharp8;
        }

        public static SyntaxTriviaList GetLeadingTriviaFromMultipleLocations(this FieldDeclarationSyntax field) {
            SyntaxTriviaList typeTrivia = field.Declaration.Type.GetCommentTrivia();
            if (typeTrivia.Any()) {
                return typeTrivia;
            }

            SyntaxTriviaList modifierTrivia = field.Modifiers.First().GetCommentTrivia();
            if (modifierTrivia.Any()) {
                return modifierTrivia;
            }

            AttributeListSyntax attributeList = field.AttributeLists[0];

            return attributeList.OpenBracketToken.GetCommentTrivia();
        }

        public static SyntaxTriviaList GetCommentTrivia(this SyntaxToken token) {
            if (token.LeadingTrivia.Any(SyntaxKind.SingleLineCommentTrivia) || token.LeadingTrivia.Any(SyntaxKind.MultiLineCommentTrivia)) {
                return token.LeadingTrivia;
            }

            return default;
        }

        public static SyntaxTriviaList GetCommentTrivia(this TypeSyntax type) {
            if (type is PredefinedTypeSyntax predefinedType) {
                return predefinedType.Keyword.GetCommentTrivia();
            }

            if (type is IdentifierNameSyntax identifier) {
                return identifier.Identifier.GetCommentTrivia();
            }

            return default;
        }

        public static IEnumerable<INamedTypeSymbol> GetAllTypeSymbol(this INamespaceSymbol namespaceSymbol) {
            ImmutableArray<INamedTypeSymbol> typeMemberList = namespaceSymbol.GetTypeMembers();

            foreach (INamedTypeSymbol? typeSymbol in typeMemberList) {
                yield return typeSymbol;
            }

            foreach (INamespaceSymbol? namespaceMember in namespaceSymbol.GetNamespaceMembers()) {
                foreach (INamedTypeSymbol? typeSymbol in GetAllTypeSymbol(namespaceMember)) {
                    yield return typeSymbol;
                }
            }
        }

        public static IEnumerable<AttributeSyntax> tryGetSpecifiedAttribute(this IEnumerable<AttributeListSyntax> attributeLists, string attributeName) {
            string noAttribute = attributeName;

            if (attributeName.EndsWith("Attribute")) {
                noAttribute = attributeName.Substring(0, attributeName.Length - 9);
            }

            foreach (AttributeListSyntax attributeList in attributeLists) {
                foreach (AttributeSyntax attribute in attributeList.Attributes) {
                    if (attributeName.Equals(attribute.Name.ToString()) || noAttribute.Equals(attribute.Name.ToString())) {
                        yield return attribute;
                    }
                }
            }
        }

    
        public static string getHasGenericName(this ClassDeclarationSyntax classDeclarationSyntax) {
            string className = classDeclarationSyntax.Identifier.ValueText;

            if (classDeclarationSyntax.TypeParameterList is null) {
                return className;
            }

            SeparatedSyntaxList<TypeParameterSyntax> typeParameters = classDeclarationSyntax.TypeParameterList.Parameters;

            // 你可以遍历这些参数，或者将它们格式化为字符串  
            string genericParameters = string.Join(", ", typeParameters.Select(tp => tp.Identifier.ValueText));

            // 输出包含泛型参数的类名  
            return $"{className}<{genericParameters}>";
        }



    }

    /// <summary>
    /// Contains definitions of diagnostics which can be raised by Lombok.NET.
    /// </summary>
    public static class DiagnosticDescriptors {

        /// <summary>
        /// Raised when a type is not partial although it should be.
        /// </summary>
        public static readonly DiagnosticDescriptor TypeMustBePartial = new
        (
            "LOM001",
            "Type must be partial",
            "The type '{0}' must be partial in order to generate code for it",
            "Usage",
            DiagnosticSeverity.Error,
            true
        );

        /// <summary>
        /// Raised when a type is not within a namespace although it should be.
        /// </summary>
        public static readonly DiagnosticDescriptor TypeMustHaveNamespace = new
        (
            "LOM003",
            "Type must have namespace",
            "The type '{0}' must be in a namespace in order to generate code for it",
            "Usage",
            DiagnosticSeverity.Error,
            true
        );

        /// <summary>
        /// Raised when a type is file-local.
        /// </summary>
        public static readonly DiagnosticDescriptor TypeCannotBeFileLocal = new
        (
            "LOM007",
            "Type cannot be file-local",
            "The type '{0}' must not be file-local in order to generate code for it.",
            "Usage",
            DiagnosticSeverity.Error,
            true
        );

    }
    

    public static class Util {

        public static void format(this string format, StringBuilder? stringBuilder, Action<string> structure) {
            if (format == null || structure == null) {
                throw new ArgumentNullException
                (
                    (format == null)
                        ? "format"
                        : "args"
                );
            }

            bool startBrace = false;
            int startBraceIndex = -1;

            for (var i = 0; i < format.Length; i++) {
                char c = format[i];

                switch (c) {
                    case '{':

                        if (startBrace) {
                            if (i - startBraceIndex == 1) {
                                startBrace = false;
                                stringBuilder?.Append('{');
                                break;
                            }
                            ThrowFormatException();
                        }

                        startBrace = true;
                        startBraceIndex = i;

                        break;
                    case '}':

                        if (!startBrace) {
                            if (i + 1 < format.Length && format[i] == '}') {
                                stringBuilder?.Append('}');
                                i++;
                                break;
                            }

                            ThrowFormatException();
                        }

                        startBrace = false;

                        string key = format.Substring(startBraceIndex + 1, i - startBraceIndex - 1);

                        structure(key);

                        break;
                    default:

                        if (!startBrace) {
                            stringBuilder?.Append(c);
                        }

                        break;
                }
            }
        }

        private static void ThrowFormatException() {
            throw new FormatException("Input string was not in a correct format.");
        }

        public static void PrintExceptionSummaryAndStackTrace(this Exception ex) {
            // 获取堆栈跟踪的第一帧  
            StackTrace stackTrace = new StackTrace(ex, true);
            StackFrame firstFrame = stackTrace.GetFrame(0);

            // 格式化文件名、行号和列号为紧凑字符串  
            string fileLocation = firstFrame.GetFileName() != null
                ? $"{firstFrame.GetFileName()}[{firstFrame.GetFileLineNumber()}, {firstFrame.GetFileColumnNumber()}]"
                : "Unknown file[0, 0]";

            // 格式化一行简化的异常信息  
            string summary = $"Exception Message: {ex.Message}, Type: {ex.GetType()}, Method: {firstFrame.GetMethod().DeclaringType?.FullName}.{firstFrame.GetMethod().Name}, Location: {fileLocation}";

            // 打印简化的异常信息  
            Console.WriteLine(summary);

            // 打印完整的堆栈跟踪信息  
            foreach (StackFrame frame in stackTrace.GetFrames() ?? Array.Empty<StackFrame>()) {
                MethodBase method = frame.GetMethod();
                string fileName = frame.GetFileName() ?? "Unknown file";
                int fileLineNumber = frame.GetFileLineNumber();
                int fileColumnNumber = frame.GetFileColumnNumber();

                string frameLocation = $"{fileName}[{fileLineNumber}, {fileColumnNumber}]";
                Console.WriteLine($"    Method: {method.DeclaringType?.FullName}.{method.Name}, Location: {frameLocation}");
            }

            Console.WriteLine();

            // 如果异常有内部异常，也打印出来  
            if (ex.InnerException != null) {
                Console.WriteLine("Inner Exception:");
                PrintExceptionSummaryAndStackTrace(ex.InnerException);
            }
        }

        public static string mackCustomName(string source, string? fillSource, MetadataAttribute metadataAttribute) {

            fillSource ??= source;

            if (metadataAttribute.customName is not null) {
                return metadataAttribute.customName;
            }

            if (metadataAttribute.customPrefix is not null) {
                return metadataAttribute.customPrefix + source.toPascalCaseIdentifier();
            }

            if (metadataAttribute.customSuffix is not null) {
                return fillSource + metadataAttribute.customSuffix;
            }

            return fillSource;
        }

    }

    public static class GeneratorUtil {

        public static MethodDeclarationSyntax applyAll<A>
        (
            this MethodDeclarationSyntax methodDeclarationSyntax,
            FieldsAttributeContext<A> fieldsAttributeContext,
            AttributeContext<A> firstAttribute
        ) where A : MetadataAttribute {
            return methodDeclarationSyntax
                .applyCustomName(firstAttribute.attribute, fieldsAttributeContext.fieldsContext.fieldName)
                .applyLink(firstAttribute.attribute, fieldsAttributeContext.basicsContext.className)
                .applyNoNull(firstAttribute.attribute)
                .applyFrozen(firstAttribute.attribute)
                .applyDeclarationSyntaxes(firstAttribute.attribute);

        }

        public static MethodDeclarationSyntax applyFrozen(this MethodDeclarationSyntax methodDeclarationSyntax, MetadataAttribute metadataAttribute) {
            if (metadataAttribute.freezeTag is null) {
                return methodDeclarationSyntax;
            }
            if (methodDeclarationSyntax.Body is null) {
                return methodDeclarationSyntax;
            }

            return methodDeclarationSyntax.WithBody
            (
                Block
                (
                    methodDeclarationSyntax.Body.Statements.Insert
                    (
                        0,
                        ExpressionStatement
                        (
                            InvocationExpression
                            (
                                MemberAccessExpression
                                (
                                    SyntaxKind.SimpleMemberAccessExpression, // 使用点号访问  ,
                                    ThisExpression(),
                                    IdentifierName
                                    (
                                        "validateNonFrozen"
                                    )
                                ),
                                ArgumentList
                                (
                                    SingletonSeparatedList
                                    (
                                        Argument
                                        (
                                            LiteralExpression
                                            (
                                                SyntaxKind.StringLiteralExpression,
                                                Literal
                                                (
                                                    metadataAttribute.freezeTag
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            );
        }
        
        public static MethodDeclarationSyntax applyNoNull(this MethodDeclarationSyntax methodDeclarationSyntax, MetadataAttribute metadataAttribute) {

            if (!metadataAttribute.noNull) {
                return methodDeclarationSyntax;
            }

            if (methodDeclarationSyntax.Body is null) {
                return methodDeclarationSyntax;
            }

            return methodDeclarationSyntax.WithBody
            (
                Block
                (
                    methodDeclarationSyntax.Body.Statements.InsertRange
                    (
                        0,
                        methodDeclarationSyntax.ParameterList.Parameters.Select
                        (
                            parameterListParameter => IfStatement
                            (
                                BinaryExpression
                                (
                                    SyntaxKind.EqualsExpression,
                                    IdentifierName(parameterListParameter.Identifier.Text),
                                    LiteralExpression(SyntaxKind.NullLiteralExpression)
                                ),
                                Block
                                (
                                    ThrowStatement
                                    (
                                        ObjectCreationExpression
                                        (
                                            ParseTypeName("System.NullReferenceException"),
                                            ArgumentList
                                            (
                                                SeparatedList
                                                (
                                                    new[] {
                                                        Argument
                                                        (
                                                            LiteralExpression
                                                            (
                                                                SyntaxKind.StringLiteralExpression,
                                                                Literal
                                                                (
                                                                    $"{methodDeclarationSyntax.Identifier.Text}.{parameterListParameter.Identifier.Text} is null"
                                                                )
                                                            )
                                                        )
                                                    }
                                                )
                                            ),
                                            null
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            );

        }
        
        public static MethodDeclarationSyntax applyCustomName(this MethodDeclarationSyntax methodDeclarationSyntax, MetadataAttribute metadataAttribute, string fieldName) {

            if (!metadataAttribute.isCustomName()) {
                return methodDeclarationSyntax;
            }

            methodDeclarationSyntax = methodDeclarationSyntax.WithIdentifier
            (
                Identifier
                (
                    Util.mackCustomName(fieldName, methodDeclarationSyntax.Identifier.Text, metadataAttribute)
                )
            );

            return methodDeclarationSyntax;

        }

        public static MethodDeclarationSyntax applyDeclarationSyntaxes(this MethodDeclarationSyntax methodDeclarationSyntax, MetadataAttribute metadataAttribute) {
            switch (metadataAttribute.accessLevel) {
                case AccessLevel.Private:
                    methodDeclarationSyntax = methodDeclarationSyntax.AddModifiers
                    (
                        Token
                        (
                            SyntaxKind.PrivateKeyword
                        )
                    );
                    break;
                case AccessLevel.Protected:
                    methodDeclarationSyntax = methodDeclarationSyntax.AddModifiers
                    (
                        Token
                        (
                            SyntaxKind.ProtectedKeyword
                        )
                    );
                    break;
                case AccessLevel.ProtectedInternal:
                    methodDeclarationSyntax = methodDeclarationSyntax.AddModifiers
                    (
                        Token
                        (
                            SyntaxKind.ProtectedKeyword
                        ),
                        Token
                        (
                            SyntaxKind.InternalKeyword
                        )
                    );
                    break;
                case AccessLevel.Internal:
                    methodDeclarationSyntax = methodDeclarationSyntax.AddModifiers
                    (
                        Token
                        (
                            SyntaxKind.InternalKeyword
                        )
                    );
                    break;
                case AccessLevel.Public:
                    methodDeclarationSyntax = methodDeclarationSyntax.AddModifiers
                    (
                        Token
                        (
                            SyntaxKind.PublicKeyword
                        )
                    );
                    break;
            }

            switch (metadataAttribute.methodType) {
                case MethodType.def:
                    break;
                case MethodType.Abstract:
                    methodDeclarationSyntax = methodDeclarationSyntax.WithBody(null)
                        .AddModifiers
                        (
                            Token
                            (
                                SyntaxKind.AbstractKeyword
                            )
                        )
                        .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
                    break;
                case MethodType.Partial:
                    methodDeclarationSyntax = methodDeclarationSyntax.WithBody(null)
                        .AddModifiers
                        (
                            Token
                            (
                                SyntaxKind.PartialKeyword
                            )
                        )
                        .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
                    break;
                case MethodType.Override:
                    methodDeclarationSyntax = methodDeclarationSyntax.AddModifiers
                    (
                        Token
                        (
                            SyntaxKind.OverrideKeyword
                        )
                    );
                    break;
                case MethodType.Virtual:
                    methodDeclarationSyntax = methodDeclarationSyntax.AddModifiers
                    (
                        Token
                        (
                            SyntaxKind.VirtualKeyword
                        )
                    );
                    break;
            }
            return methodDeclarationSyntax;
        }

        public static MethodDeclarationSyntax applyLink
        (
            this MethodDeclarationSyntax methodDeclarationSyntax,
            MetadataAttribute metadataAttribute,
            string className
        ) {
            if (!metadataAttribute.link) {
                return methodDeclarationSyntax;
            }

            TypeSyntax returnType = methodDeclarationSyntax.ReturnType;
            if (!returnType.ToString().Equals("void")) {
                return methodDeclarationSyntax;
            }

            methodDeclarationSyntax = methodDeclarationSyntax
                .WithReturnType
                (
                    IdentifierName(className)
                );

            if (methodDeclarationSyntax.Body is null) {
                return methodDeclarationSyntax;
            }

            return methodDeclarationSyntax
                .AddBodyStatements
                (
                    ReturnStatement
                    (
                        ThisExpression()
                    )
                );
        }

        public static MethodDeclarationSyntax applyUpdateField(this MethodDeclarationSyntax methodDeclarationSyntax, MetadataAttribute metadataAttribute, string fieldName) {

            if (!metadataAttribute.updateField) {
                return methodDeclarationSyntax;
            }

            if (methodDeclarationSyntax.Body is null) {
                return methodDeclarationSyntax;
            }

            return methodDeclarationSyntax
                .WithBody
                (
                    Block
                    (
                        methodDeclarationSyntax.Body.Statements.Insert
                        (
                            0,
                            IfStatement
                            (
                                InvocationExpression
                                (
                                    MemberAccessExpression
                                    (
                                        SyntaxKind.SimpleMemberAccessExpression,
                                        IdentifierName
                                        (
                                            "object"
                                        ),
                                        IdentifierName
                                        (
                                            nameof(Equals)
                                        )
                                    ),
                                    ArgumentList
                                    (
                                        SeparatedList
                                        (
                                            new[] {
                                                Argument
                                                (
                                                    MemberAccessExpression
                                                    (
                                                        SyntaxKind.SimpleMemberAccessExpression,
                                                        ThisExpression(),
                                                        IdentifierName
                                                        (
                                                            fieldName
                                                        )
                                                    )
                                                ),
                                                Argument
                                                (
                                                    IdentifierName
                                                    (
                                                        fieldName
                                                    )
                                                ),
                                            }
                                        )
                                    )
                                ),
                                Block
                                (
                                    ExpressionStatement
                                    (
                                        InvocationExpression
                                        (
                                            MemberAccessExpression
                                            (
                                                SyntaxKind.SimpleMemberAccessExpression, // 使用点号访问  ,
                                                ThisExpression(),
                                                IdentifierName
                                                (
                                                    "update" + fieldName.toPascalCaseIdentifier()
                                                )
                                            ),
                                            ArgumentList
                                            (
                                                SeparatedList
                                                (
                                                    new[] {
                                                        Argument
                                                        (
                                                            MemberAccessExpression
                                                            (
                                                                SyntaxKind.SimpleMemberAccessExpression,
                                                                ThisExpression(),
                                                                IdentifierName
                                                                (
                                                                    fieldName
                                                                )
                                                            )
                                                        ),
                                                        Argument
                                                        (
                                                            IdentifierName
                                                            (
                                                                fieldName
                                                            )
                                                        ),
                                                    }
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                );
        }

    }

    public class CodeBuilder {

        public readonly StringBuilder stringBuilder;

        public int indentation;

        protected bool start;

        public CodeBuilder(StringBuilder stringBuilder) {
            this.stringBuilder = stringBuilder;
        }

        public void append(string s) {
            if (start) {
                start = false;
                for (int i = 0; i < indentation; i++) {
                    stringBuilder.Append("    ");
                }
            }
            stringBuilder.Append(s);
        }

        public IDisposable appendBracket(string s) {
            append(s);
            return appendBracket();
        }

        public IDisposable appendBracket() {
            stringBuilder.Append('(');
            return new CodeBuilderDisposable(() => append(")"));
        }

        public void appendLine(string s) {
            append(s);
            stringBuilder.Append('\n');
            start = true;
        }

        public IDisposable appendBlock(string s = "", bool lineFeed = true) {
            append(s);
            return block(lineFeed);
        }

        public IDisposable block(bool lineFeed = true) {
            indentation++;
            stringBuilder.Append(' ').Append('{').Append('\n');
            start = true;
            return new CodeBuilderDisposable
            (
                () => {
                    indentation--;
                    if (lineFeed) {
                        appendLine("}");
                    }
                    else {
                        append("}");
                    }
                }
            );
        }

        public class CodeBuilderDisposable : IDisposable {

            public readonly Action dispose;

            public CodeBuilderDisposable(Action dispose) {
                this.dispose = dispose;
            }

            public void Dispose() => dispose();

        }

    }
    

}
